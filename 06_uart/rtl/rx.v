
module rx (
    input  wire       clk,     // global clock input
    input  wire       rst,     // global reset input

    input  wire       ce16_i,  // baud rate multiplyed by 16 - generated by baud module
    input  wire       rx_i,    // serial data input
    output reg  [7:0] data_o,  // data byte received
    output reg        next_o   // signs that a new byte was received
);

    // internal registers
    reg [3:0] cnt;
    reg [1:0] sync;
    reg       rx_busy;
    reg [3:0] bit_cnt;
    reg [7:0] data_buf;

    // clk enable at bit rate
    // ce1 pulse indicating expected end of current bit
    wire ce1     = (cnt == 4'b1111) & ce16_i;
    // clk enable at the middle of each bit - used to sample data
    // ce1_mid pulse indication the sampling clk cycle of the current data bit
    wire ce1_mid = (cnt == 4'b0111) & ce16_i;

    // module implementation
    // input async input is sampled twice
    always @( posedge clk ) begin
        if ( rst ) begin
            sync <= 2'b11;
        end
        else begin
            sync <= {sync[0], rx_i};
        end
    end

    // a counter to count 16 pulses of ce16_i to generate the ce1 and ce1_mid pulses.
    // this counter is used to detect the start bit while the receiver is not receiving and
    // signs the sampling cycle during reception.
    always @( posedge clk ) begin
        if ( rst ) begin
            cnt <= 4'b0;
        end
        else if ( ce16_i ) begin
            if ( rx_busy | (sync[1] == 1'b0) ) begin
                cnt <= cnt + 4'b1;
            end
            else begin
                cnt <= 4'b0;
            end
        end
    end

    // receiving busy flag
    always @ ( posedge clk ) begin
        if ( rst ) begin
            rx_busy <= 1'b0;
        end
        else if ( ~rx_busy & ce1_mid ) begin
            rx_busy <= 1'b1;
        end
        else if ( rx_busy & (bit_cnt == 4'h8) & ce1_mid ) begin
            rx_busy <= 1'b0;
        end
    end

    // bit counter
    always @ ( posedge clk ) begin
        if ( rst ) begin
            bit_cnt <= 4'h0;
        end
        else if ( ~rx_busy ) begin
            bit_cnt <= 4'h0;
        end
        else if ( rx_busy & ce1_mid ) begin
            bit_cnt <= bit_cnt + 4'h1;
        end
    end

    // data buffer shift register
    always @ ( posedge clk ) begin
        if ( rst ) begin
            data_buf <= 8'h0;
        end
        else if ( rx_busy & ce1_mid ) begin
            data_buf <= {sync[1], data_buf[7:1]};
        end
    end

    // data output and flag
    always @ ( posedge clk ) begin
        if ( rst ) begin
            data_o <= 8'h0;
            next_o <= 1'b0;
        end
        else if ( rx_busy & (bit_cnt == 4'h8) & ce1 ) begin
            data_o <= data_buf;
            next_o <= 1'b1;
        end
        else begin
            next_o <= 1'b0;
        end
    end

endmodule
