
module tx (
    input  wire       clk,      // global clock input
    input  wire       rst,      // global reset input

    input  wire       ce16_i,   // baud rate multiplyed by 16 - generated by baud module
    input  wire [7:0] data_i,   // data byte to transmit
    input  wire       next_i,   // asserted to indicate that there is a new data byte for transmission
    output reg        tx_o,     // serial data output
    output reg        tx_busy_o // signs that transmitter is busy
);

    // internal registers
    reg [3:0] cnt;
    reg [3:0] bit_cnt;
    reg [8:0] data_buf;

    // clk enable at bit rate
    // ce1 pulse indicating output data bit should be updated
    wire ce1 = (cnt == 4'b1111) & ce16_i;

    // a counter to count 16 pulses of ce16_i to generate the ce1 pulse
    always @ ( posedge clk ) begin
        if ( rst ) begin
            cnt <= 4'b0;
        end
        else if ( tx_busy_o & ce16_i ) begin
            cnt <= cnt + 4'b1;
        end
        else if ( ~tx_busy_o ) begin
            cnt <= 4'b0;
        end
    end

    // tx_busy_o flag
    always @ ( posedge clk ) begin
        if ( rst ) begin
            tx_busy_o <= 1'b0;
        end
        else if ( ~tx_busy_o & next_i ) begin
            tx_busy_o <= 1'b1;
        end
        else if ( tx_busy_o & (bit_cnt == 4'h9) & ce1 ) begin
            tx_busy_o <= 1'b0;
        end
    end

    // output bit counter
    always @ ( posedge clk ) begin
        if ( rst ) begin
            bit_cnt <= 4'h0;
        end
        else if ( tx_busy_o & ce1 ) begin
            bit_cnt <= bit_cnt + 4'h1;
        end
        else if ( ~tx_busy_o ) begin
            bit_cnt <= 4'h0;
        end
    end

    // data shift register
    always @ ( posedge clk ) begin
        if ( rst ) begin
            data_buf <= 9'b0;
        end
        else if ( ~tx_busy_o ) begin
            data_buf <= {data_i, 1'b0};
        end
        else if ( tx_busy_o & ce1 ) begin
            data_buf <= {1'b1, data_buf[8:1]};
        end
    end

    // output data bit
    always @ ( posedge clk ) begin
        if ( rst ) begin
            tx_o <= 1'b1;
        end
        else if ( tx_busy_o ) begin
            tx_o <= data_buf[0];
        end
        else begin
            tx_o <= 1'b1;
        end
    end

endmodule
